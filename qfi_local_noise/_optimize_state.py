import itertools
import functools
import logging
logger = logging.getLogger(__name__)

import numpy as np
import numpy.linalg as npl
import numpy.random as npr
import numpy.fft as npf

from tqdm.auto import tqdm

import scipy as sp
import scipy.linalg as spl
import scipy.special as spa
import scipy.sparse as sps
import scipy.sparse.linalg as spsl
import scipy.optimize as spo

import qutip

from ._util import abs2, _validate, NS, multiprocessing_streams_init_pool

from ._states_desc import (
    KetDesc
)

from ._symm_states_desc import (
    SymmetricKet
)


# Special logger for all the _validate calls, so that it can be silenced easily.
# The logger instance will be found by name in the global scope of this module
# by the _validate() command itself.
from .validate import validate_logger




# ------------------------------------------------
# Base Routines
# ------------------------------------------------



class OptimizationStateAnsatz:
    r"""
    ............

    Note: If the vector is not normalized, then a penalty term is added with the
    normalization, so it's assumed that the parameters *DO* have a way of
    picking up the normalized vector by themselves.  If this is not the case,
    then you should normalize the vector manually.
    """
    def __init__(self, n, localdim, *, num_parameters, states_are_normalized):
        self.n = n
        self.localdim = localdim
        self.num_parameters = num_parameters
        self.states_are_normalized = states_are_normalized

    def get_state(self, x, **kwargs):
        raise RuntimeError("Subclass doesn't reimplement get_state()")

    def sample_random_x0(self, **kwargs):
        raise RuntimeError("Subclass doesn't reimplement sample_random_x0()")





class StateOptimizer:
    r"""
    - `ansatz` is an instance of one of the `OptimizationStateAnsatz` defined
      above

    - `compute_fn` is a function (or callable) that accepts a `state_desc` as
      its single argument (the state generated by the Ansatz) and returns a
      single number which is the figure of merit to optimize (Bob's quantum
      Fisher information).
    """
    def __init__(self, ansatz, compute_fn):
        super().__init__()
        self.ansatz = ansatz
        self.n = self.ansatz.n
        self.localdim = self.ansatz.localdim

        self.compute_fn = compute_fn

        # advanced settings can be set directly

        self.base_tol = 1e-3
        self.norm_tol = 1e-3

        self.disp = False
        self.penalty_norm_factor = 1.0
        self.local_optim_refine_with_powell = False

        
    def _optim_fun(self, x):
        state_desc = self.ansatz.get_state(x)
        penalty_term = 0
        if not self.ansatz.states_are_normalized:
            # states aren't normalized, we need to normalize it
            the_norm = state_desc.norm()
            state_desc = state_desc.normalized_by(the_norm)
            # add penalty term to try to force normalization
            penalty_term = self.penalty_norm_factor*self.n*self.n*np.square(1-the_norm)/self.norm_tol

        FI_value = self.compute_fn(state_desc)
        return -FI_value + penalty_term

    def optimize_local(self, x0=None, rndn=None):
        result = self._optimize_local(x0, rndn)
        result = self.finalize_optimization(result)
        return result

    def _get_x0(self, x0, rndn):
        if x0 is not None:
            return x0
        if rndn is not None:
            npr.seed(rndn)
        return self.ansatz.sample_random_x0(rndn=rndn)

    def _optimize_local(self, x0, rndn):
        x0 = self._get_x0(x0, rndn)
        logger.debug("Starting local optimization from x0=%r (# of parameters = %d)", x0, len(x0))
        result = spo.minimize(
            self._optim_fun,
            x0,
            method='L-BFGS-B', # -- wow, fast ! looks like we get a pretty accurate minimum, too
            #method='BFGS', # -- ?
            #method='Powell', # -- a bit slower, but prettier/cleaner resulting pmvec.
            #method='BFGS', # -- slower
            #method='CG', # -- really slow :(
            tol=self.base_tol,
            options=dict(
                disp=1,
                iprint=1 if self.disp else -1,
                #ftol=1e-3, xtol=0.05, #Powell
            )
        )
        if self.local_optim_refine_with_powell:
            # Refine with Powell method
            logger.debug("Refining result with Powell algorithm with x0=%r", result.x)
            result = spo.minimize(
                self._optim_fun,
                result.x,
                method='Powell', # -- a bit slower, but prettier/cleaner resulting pmvec.
                tol=0.1*self.base_tol, #1e-4,
                options=dict(
                    disp=self.disp,
                    #ftol=1e-3, xtol=0.05, #Powell
                )
            )
        return result


    def _optimize_do_shots_serial(self, num_shots, *, rndn_base=0, tqdm=tqdm):

        result_shots = []
        for j in tqdm(range(num_shots), desc="Optimization with random shots ðŸŽ¯",
                      total=num_shots):
            r = self._optimize_local(None, rndn_base+j)
            result_shots.append(r)

        return result_shots

    def _optimize_do_shots_mp(self, num_shots, *, rndn_base=0, tqdm=tqdm,
                              processes=None, chunksize=None):

        import multiprocessing

        mp_pool_imap_kwargs = dict()
        if chunksize:
            mp_pool_imap_kwargs.update(chunksize=chunksize)

        mp_pool_kwargs = dict(
            initializer=_mp_optim_init_pool
        )
        if processes:
            mp_pool_kwargs.update(processes=processes)

        result_shots = []

        with multiprocessing.Pool(**mp_pool_kwargs) as pool:
            for r in tqdm(
                    pool.imap_unordered( _LocalOptimizerFn(self, rndn_base),
                                         list(range(num_shots)),
                                         **mp_pool_imap_kwargs ),
                    desc="Parallel optimization with random shots ðŸŽ¯ðŸŽ¯ðŸŽ¯",
                    total=num_shots
            ):
                result_shots.append(r)

        return result_shots

        

    def optimize_shots(self, num_shots=20, *, parallel=True, rndn_base=0, tqdm=tqdm, **kwargs):

        if parallel:
            result_shots = self._optimize_do_shots_mp(
                num_shots,
                rndn_base=rndn_base,
                tqdm=tqdm,
                **kwargs
            )
        else:
            result_shots = self._optimize_do_shots_serial(
                num_shots,
                rndn_base=rndn_base,
                tqdm=tqdm,
            )

        global_min_j = functools.reduce(
            lambda a, b: a if result_shots[a].fun < result_shots[b].fun else b,
            range(len(result_shots))
        )

        result = NS()
        result.shots = result_shots
        result.global_min_j = global_min_j
        result.x = result.shots[global_min_j].x
        result.fun = result.shots[global_min_j].fun

        result = self.finalize_optimization(result)

        return result

    def callback_global_optimization_at_minimum(self, x, f, accepted):
        logger.debug("at minimum %.4f accepted %d -- %r", f, int(accepted), x)

    def optimize_basinhopping(self, *, x0=None, rndn=None, basinhopping_kwargs=dict()):

        x0 = self._get_x0(x0, rndn)

        logger.debug("Starting basinhopping optimization ...")

        result = spo.basinhopping(
            self._optim_fun,
            x0,
            minimizer_kwargs=dict(method='L-BFGS-B', tol=self.base_tol),
            callback=self.callback_global_optimization_at_minimum,
            **basinhopping_kwargs
        )

        result = self.finalize_optimization(result)

        return result


    def finalize_optimization(self, result):
        
        # recompute the value at this point (to eliminate any penalty factor)
        state_desc = self.ansatz.get_state(result.x)
        result.state_desc = state_desc
        result.F_Bob = self.compute_fn(state_desc)

        if np.absolute(state_desc.norm() - 1) >= self.norm_tol:
            logger.error("Optimization didn't converge onto a normalized state. "
                         "You might want to try increasing `self.penalty_norm_factor`")

        logger.debug("Final optimization result is: %r", result)

        return result




# needs to be a global definition because multiprocess needs to be able
# to pickle this class
class _LocalOptimizerFn:
    def __init__(self, opt, rndn_base):
        self.opt = opt
        self.rndn_base = rndn_base

    def __call__(self, j):
        return self.opt._optimize_local(None, self.rndn_base+j)


def _mp_optim_init_pool():
    multiprocessing_streams_init_pool()


# ------------------------------------------------
# AnsÃ¤tze for "ditstring-based" systems
# ------------------------------------------------



# ------------------------------------------------
# AnsÃ¤tze for Symmetric States
# ------------------------------------------------


class SymmetricRealStateAnsatz(OptimizationStateAnsatz):
    def __init__(self, n, localdim):
        super().__init__(n, localdim,
                         num_parameters=n+1,
                         states_are_normalized=False)

        # only works for qubits for now
        _validate(r""" $localdim == 2 """)

    def get_state(self, x):
        _validate(r""" tuple($x .shape) == (self.num_parameters,) """)
        return SymmetricKet(self.n, 2, x)

    def sample_random_x0(self, *, alpha=0.75, rndn=None):
        # random +/- 1 for each symmetric basis vector
        return np.multiply(
            np.sqrt(npr.dirichlet(alpha*np.ones(self.n+1),size=1)),
            2*np.random.randint(0,2,size=self.n+1)-1
        )


class SymmetricFullStateAnsatz(OptimizationStateAnsatz):
    def __init__(self, n, localdim):
        super().__init__(n, localdim,
                         num_parameters=2*(n+1),
                         states_are_normalized=False)

        # only works for qubits for now
        _validate(r""" $localdim == 2 """)

    def get_state(self, x):
        _validate(r""" tuple($x .shape) == (self.num_parameters,) """)
        return SymmetricKet(self.n, 2,
                            x[:self.n+1] + 1j*x[self.n+1:])

    def sample_random_x0(self, *, alpha=0.75, rndn=None):
        ndim = self.n+1
        x0z = np.multiply(
            np.sqrt(npr.dirichlet(alpha*np.ones(ndim),size=1)),
            np.exp(1j*npr.uniform(-np.pi, np.pi, ndim))
        )
        return np.vstack([x0z.real, x0z.imag])


class SymmetricExponentialTailsStateAnsatz(OptimizationStateAnsatz):
    def __init__(self, n, localdim, same_w_either_side=False):
        if same_w_either_side:
            num_parameters = 2
        else:
            num_parameters = 3
        super().__init__(n, localdim,
                         num_parameters=num_parameters,
                         states_are_normalized=True)

        self.same_w_either_side = same_w_either_side

        # only works for qubits for now
        _validate(r""" $localdim == 2 """)

    def sample_random_x0(self, rndn=None):

        if not rndn: # None or zero
            if self.same_w_either_side:
                return np.array([0.2, 0])
            return np.array([0.2, 0.2, 0])

        if self.same_w_either_side:
            return [ 1/npr.uniform(1, 10), npr.uniform(1e-2, 1) ]
        return [ 1/npr.uniform(1, 10), 1/npr.uniform(1, 10), npr.uniform(1e-2, 1) ]

    def get_state(self, x):
        _validate(r""" tuple($x .shape) == (self.num_parameters,) """)

        a = 1
        if self.same_w_either_side:
            w1, c = x
            w2 = w1
        else:
            w1, w2, c = x

        amplvec = a*np.exp(-np.arange(self.n+1)/(w1*w1*self.n)) \
            + a*np.exp(-(self.n-np.arange(self.n+1))/(w2*w2*self.n)) + c

        amplvec = amplvec / npl.norm(amplvec)
        #print(f"{x=};  {amplvec = }")
        return SymmetricKet(self.n, 2, amplvec)




class SymmetricExponentialPeaksStateAnsatz(OptimizationStateAnsatz):
    def __init__(self, n, localdim, num_peaks=2, all_peaks_same_width=False):
        if all_peaks_same_width:
            # position & amplitude of each peak + a single width parameter 
            num_parameters = 2*num_peaks + 1
        else:
            # position, amplitude & width of each peak
            num_parameters = 3*num_peaks
        super().__init__(n, localdim,
                         num_parameters=num_parameters,
                         states_are_normalized=True)

        # only works for qubits for now
        _validate(r""" $localdim == 2 """)

        self.num_peaks = num_peaks
        self.all_peaks_same_width = all_peaks_same_width

        self.peak_pos_idx = np.arange(self.num_peaks)
        self.peak_ampl_idx = np.arange(self.num_peaks, 2*self.num_peaks)
        if all_peaks_same_width:
            self.peak_width_idx = np.array([2*self.num_peaks])
        else:
            self.peak_width_idx = np.arange(2*self.num_peaks, 3*self.num_peaks)

    def sample_random_x0(self, rndn=None):
        if not rndn: # None or zero
            x = np.zeros(shape=(self.num_parameters,))
            x[self.peak_pos_idx] = np.linspace(0, self.n+1, self.num_peaks)
            x[self.peak_ampl_idx] = 1
            x[self.peak_width_idx] = 0.2
            return x

        x = np.zeros(shape=(self.num_parameters,))
        x[self.peak_pos_idx] = npr.uniform(0, self.n+1, self.num_peaks)
        x[self.peak_ampl_idx] = npr.uniform(0.1, 2, self.num_peaks)
        x[self.peak_width_idx] = 1/npr.uniform(1, 10, len(self.peak_width_idx))
        return x

    def get_state(self, x):
        _validate(r""" tuple($x .shape) == (self.num_parameters,) """)

        peak_pos = x[self.peak_pos_idx]
        peak_ampl = x[self.peak_ampl_idx]
        peak_w = np.square(x[self.peak_width_idx]) # either single scalar or array

        # create an array in which the first dimension list the individual terms
        # and the second dimension is 0...n
        expterms = (
            peak_ampl[:,np.newaxis] *
            np.exp(-np.absolute(np.arange(self.n+1).reshape( (1,self.n+1) ) - peak_pos[:,np.newaxis]) /
                   (peak_w[:,np.newaxis] * self.n))
        )
        # sum along first axis to get the coefficients of the state vector (not
        # normalized yet)
        psi_coeffs_nn = expterms.sum(axis=0)
        assert psi_coeffs_nn.shape == (self.n+1,)

        the_norm = npl.norm(psi_coeffs_nn)
        psi_coeffs = psi_coeffs_nn / the_norm

        return SymmetricKet(self.n, 2, psi_coeffs)

    







def _validate_num_fft_terms_and_get_num_params(n, num_fft_terms):
    if num_fft_terms > (n//2+1):
        raise ValueError("num_fft_terms must be â‰¤ (floor(n/2)+1)")
    r_num_fft_terms = num_fft_terms
    if num_fft_terms >= n//2+1:
        # there is overlap, count the "right" ones once only
        r_num_fft_terms = n//2
    num_params = 2*num_fft_terms + 2*r_num_fft_terms + 1
    return num_fft_terms, r_num_fft_terms, num_params

class SymmetricFFTModesStateAnsatz(OptimizationStateAnsatz):
    def __init__(self, n, localdim, *, num_fft_terms=3):
        num_fft_terms, r_num_fft_terms, num_parameters = \
            _validate_num_fft_terms_and_get_num_params(n, num_fft_terms)
        super().__init__(n, localdim,
                         num_parameters=num_parameters,
                         states_are_normalized=False)

        _validate(r""" $localdim == 2 """)
        
        self.ndim = n+1
        self.num_fft_terms = num_fft_terms
        self.r_num_fft_terms = r_num_fft_terms

    def sample_random_x0(self, rndn=None, **kwargs):
        if not rndn: # None or zero
            # parameters so that the wave function is the constant 1/\sqrt{n};
            # note 1/n of the inverse Fourier formula
            # https://docs.scipy.org/doc/numpy/reference/routines.fft.html#implementation-details
            x = np.zeros(self.num_parameters)
            x[-1] = np.sqrt(self.ndim)
            return x
        return npr.uniform(-1, 1, self.num_parameters)

    def get_state(self, x):
        ndim = self.ndim
        fftvec = self.fft_vec(x)
        amplvec = npf.ifft(fftvec, ndim)
        return SymmetricKet(self.n, 2, amplvec)

    def fft_vec(self, x):
        ndim = self.ndim
        num_fft_terms = self.num_fft_terms
        r_num_fft_terms = self.r_num_fft_terms

        fftvec = np.zeros(ndim, dtype=complex)
        fftvec[1:num_fft_terms+1] = \
            x[:num_fft_terms] + 1j*x[num_fft_terms:2*num_fft_terms]
        fftvec[ndim-r_num_fft_terms:] = \
            x[2*num_fft_terms:2*num_fft_terms+r_num_fft_terms] + \
            1j*x[2*num_fft_terms+r_num_fft_terms:2*num_fft_terms+2*r_num_fft_terms]
        fftvec[0] = x[2*num_fft_terms+2*r_num_fft_terms]
        return fftvec


